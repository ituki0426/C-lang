# 配列全体へのポインタとは？

アドレス演算子を使用した場合```&a```
で生成されるのは配列全体へのポインタである。

では配列全体へのポインタとは何か？

例
```c
int a[5];
```

この時の```a```
と
```&a```
の違い。

結論

アドレスそのものは```a```と書いたとき（先頭配列へのポインタ）と変わらないが、型が異なる。

・```a```=```int *```//(```int```型の配列へのポインタ。要素がいくつあるかはわからない)

・```&a```=```int (*)[5]``` (```int```が5つの配列へのポインタ)//つまり、より細かく指定される。

 # 配列へのポインタ
 
 宣言
 
 ```data_type (*var_name)[size_of_array];```
 
 例
 
 ```int (*ptr)[5];```
 
 この時、ptrは整数の要素を5個持つ配列へのポインタとなる。
 
 この時、以下のようにするとエラーが発生する。
 
 ```c
 int a[5]={1,2,3,4,5}
 int (*ptr)[5];
 ptr=a;//エラー
 ```
 
 理由としては、```int (*ptr)[5];```では、int型の要素を5つもつ配列だと宣言しているのに、ただ```ptr=a```と書くと、```a```はint型のポインタへの配列であるということしか示さない。
 
 よって、型が違うためエラーが発生する。
 
 そこで先ほど説明した、配列全体へのポインタ```&a```を用いて以下のように書く。
 
 ```c
 int a[5]={1,2,3,4,5}
 int (*ptr)[5];
 ptr=&a;//成功
 ```
 
 値にアクセスするには？
 
 以下のようにする。
 
 ```*(q)[i]```
 
 こうすることで先頭からi番目の要素にアクセスることが出来る。
 
 
 
 # 間接演算子と添え字演算子
 
 以下のように宣言する。
 
 ```c
 int a[5];
 int *p;
 p=a;
 ```
 
 以下の式はすべて、先頭からi個後ろの要素を表す。
 ```a[i]```
 ```a[i]```
 ```a[i]```
 ```a[i]```
 
 また、以下の式はすべて、先頭からi個後ろの要素へのポインタ。
 
 また、p+1の意味とは？
 
 結論
 
 pはint型で定義してる。よって、+1すると1*4で+4byte先のアドレスを指す。よって、配列の次の要素にアクセスすることが出来る。
 
 
 # アドレス演算
 ```c
 #include<stdio.h>
int main(void){
	int a[3][3]={{1,2,3},{4,5,6},{7,8,9}};
	int (*q)[2];//配列へのポインタ
	int (*f)[3];
	int *R;
	f=a;
	R=a;
	q=a;
	printf("a=%d \nq+1=%d\nR+1=%d\n",a,q+1,R+1);
	//qはintの2型なので、+1すると4×2bit、つまり、8bit先に進む。
	//Rはただのint型なので4bitのみ進む。
	printf("*R=%d\n",*R);
	printf("*(R+1)%d\n",*(R+1));
	printf("*(R+2)=%d\n",*(R+2));
	printf("*(R+3)=%d\n",*(R+3));
	printf("*(R+4)=%d\n",*(R+4));
	printf("*(R+5)=%d\n",*(R+5));
	printf("*(R+6)=%d\n",*(R+6));
	printf("*(q)[0]=%d\n",*(q)[0]);//1、q[0]=q+0、
	printf("*(q)[1]=%d\n",*(q)[1]);//3、q[1]=q+1、
	printf("*(q)[2]=%d\n",*(q)[2]);//5、q[2]=q+2、
	printf("*(q)[2]=%d\n",*(q)[3]);//7、q[3]=q+3
	printf("*(f)[0]%d\n",*(f)[0]);//1、f[0]=f+0
	printf("*(f)[1]=%d\n",*(f)[1]);//4、f[1]=f+1→f+(2*1)バイト先の要素つまり、先頭から4個先の要素
	printf("*(f)[2]=%d\n",*(f)[2]);//7、f[2]=f+2→f+(2*3)バイト先の要素つまり、先頭から6個先の要素

}
 ```
 ```
a=6421984 
q+1=6421992
R+1=6421988
*R=1
*(R+1)2
*(R+2)=3
*(R+3)=4
*(R+4)=5
*(R+5)=6
*(R+6)=7
*(q)[0]=1
*(q)[1]=3
*(q)[2]=5
*(q)[2]=7
*(f)[0]1
*(f)[1]=4
*(f)[2]=7
 ```
 
